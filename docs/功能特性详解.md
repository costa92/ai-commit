# AI-Commit åŠŸèƒ½ç‰¹æ€§è¯¦è§£

## 1. æ™ºèƒ½å·®å¼‚åˆ†æå¼•æ“

### 1.1 å¤§æ–‡ä»¶æ™ºèƒ½å¤„ç†
å½“æ£€æµ‹åˆ°å¤§å‹å˜æ›´æ—¶ï¼ŒAI-Commitä¼šè‡ªåŠ¨å¯ç”¨æ™ºèƒ½æ‘˜è¦æ¨¡å¼ï¼š

**è§¦å‘æ¡ä»¶**ï¼š
- å•æ¬¡diffå†…å®¹è¶…è¿‡10,000å­—ç¬¦
- æ¶‰åŠæ–‡ä»¶æ•°é‡è¶…è¿‡5ä¸ª

**å¤„ç†ç­–ç•¥**ï¼š
```rust
// è‡ªåŠ¨åˆ†æå˜æ›´è§„æ¨¡
let analysis = DiffAnalysis::analyze_diff(diff);

if analysis.is_large_diff || analysis.is_multi_file {
    // ç”Ÿæˆæ‘˜è¦åŒ–æç¤ºè¯ï¼Œé¿å…æ–‡ä»¶åç½—åˆ—
    let optimized_prompt = create_summarized_prompt(&analysis, diff, prompt);
}
```

**æ™ºèƒ½æ¨æ–­é€»è¾‘**ï¼š
- **å˜æ›´ç±»å‹æ¨æ–­**ï¼šåŸºäºæ–‡ä»¶å˜æ›´æ¨¡å¼è‡ªåŠ¨æ¨æ–­commitç±»å‹
  - æ–°å¢æ–‡ä»¶ â†’ `feat`
  - æµ‹è¯•æ–‡ä»¶å˜æ›´ â†’ `test`
  - æ–‡æ¡£æ–‡ä»¶å˜æ›´ â†’ `docs`
  - å…¶ä»–ä¿®æ”¹ â†’ `refactor`

- **ä½œç”¨åŸŸæ¨æ–­**ï¼šåŸºäºæ–‡ä»¶è·¯å¾„æ™ºèƒ½æ¨æ–­scope
  - `src/ai/` â†’ `ai`
  - `src/config/` â†’ `config`
  - `tests/` â†’ `test`
  - `docs/` â†’ `docs`

**ç¤ºä¾‹å¯¹æ¯”**ï¼š
```bash
# ä¼ ç»Ÿæ–¹å¼ï¼ˆä¸æ¨èï¼‰
"ä¿®æ”¹src/ai/mod.rsã€src/config/mod.rsã€src/git/tag.rsç­‰å¤šä¸ªæ–‡ä»¶"

# æ™ºèƒ½æ‘˜è¦ï¼ˆæ¨èï¼‰
"refactor(core): é‡æ„æ¨¡å—æ¶æ„æå‡æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§"
```

### 1.2 å˜æ›´ç»Ÿè®¡åˆ†æ
```rust
pub struct DiffAnalysis {
    pub total_files: usize,        // æ€»æ–‡ä»¶æ•°
    pub total_additions: usize,    // æ€»æ–°å¢è¡Œæ•°
    pub total_deletions: usize,    // æ€»åˆ é™¤è¡Œæ•°
    pub file_changes: Vec<FileChange>,  // è¯¦ç»†æ–‡ä»¶å˜æ›´
    pub is_large_diff: bool,       // æ˜¯å¦ä¸ºå¤§å‹å˜æ›´
    pub is_multi_file: bool,       // æ˜¯å¦ä¸ºå¤šæ–‡ä»¶å˜æ›´
    pub primary_change_type: String,   // ä¸»è¦å˜æ›´ç±»å‹
    pub dominant_scope: Option<String>, // ä¸»è¦ä½œç”¨åŸŸ
}
```

## 2. å¤šAIæœåŠ¡æä¾›å•†æ”¯æŒ

### 2.1 æ”¯æŒçš„æœåŠ¡æä¾›å•†

#### Ollamaï¼ˆæœ¬åœ°æœåŠ¡ï¼Œé»˜è®¤ï¼‰
```bash
# é…ç½®ç¤ºä¾‹
AI_COMMIT_PROVIDER=ollama
AI_COMMIT_MODEL=mistral
AI_COMMIT_OLLAMA_URL=http://localhost:11434/api/generate
```

**ç‰¹ç‚¹**ï¼š
- âœ… æ•°æ®éšç§æ€§å¥½ï¼ˆæœ¬åœ°å¤„ç†ï¼‰
- âœ… æ— APIè°ƒç”¨è´¹ç”¨
- âœ… æ”¯æŒå¤šç§å¼€æºæ¨¡å‹
- âŒ éœ€è¦æœ¬åœ°å®‰è£…å’Œé…ç½®
- âŒ ç¡¬ä»¶è¦æ±‚è¾ƒé«˜

#### Deepseekï¼ˆäº‘ç«¯æœåŠ¡ï¼‰
```bash
# é…ç½®ç¤ºä¾‹
AI_COMMIT_PROVIDER=deepseek
AI_COMMIT_MODEL=deepseek-chat
AI_COMMIT_DEEPSEEK_API_KEY=sk-your-key
AI_COMMIT_DEEPSEEK_URL=https://api.deepseek.com/v1/chat/completions
```

**ç‰¹ç‚¹**ï¼š
- âœ… å“åº”é€Ÿåº¦å¿«
- âœ… æ¨¡å‹è´¨é‡é«˜
- âœ… æ”¯æŒä¸­æ–‡ä¼˜åŒ–
- âŒ éœ€è¦API Key
- âŒ æœ‰ä½¿ç”¨è´¹ç”¨

#### SiliconFlowï¼ˆäº‘ç«¯æœåŠ¡ï¼‰
```bash
# é…ç½®ç¤ºä¾‹
AI_COMMIT_PROVIDER=siliconflow
AI_COMMIT_MODEL=Qwen/Qwen2.5-7B-Instruct
AI_COMMIT_SILICONFLOW_API_KEY=sk-your-key
AI_COMMIT_SILICONFLOW_URL=https://api.siliconflow.cn/v1/chat/completions
```

**ç‰¹ç‚¹**ï¼š
- âœ… æ¨¡å‹é€‰æ‹©ä¸°å¯Œ
- âœ… æ”¯æŒæœ€æ–°æ¨¡å‹
- âœ… æ€§ä»·æ¯”è¾ƒé«˜
- âŒ éœ€è¦API Key
- âŒ ç½‘ç»œä¾èµ–

### 2.2 ç»Ÿä¸€çš„APIæ¥å£è®¾è®¡
```rust
// ç»Ÿä¸€çš„è¯·æ±‚å¤„ç†
match config.provider.as_str() {
    "siliconflow" | "deepseek" => {
        // ä½¿ç”¨OpenAIå…¼å®¹çš„APIæ ¼å¼
        let request = DeepseekRequest {
            model: &config.model,
            messages: vec![DeepseekMessage {
                role: "user",
                content: &optimized_prompt,
            }],
            stream: true,
        };
    }
    _ => {
        // ä½¿ç”¨OllamaåŸç”ŸAPIæ ¼å¼
        let request = OllamaRequest {
            model: &config.model,
            prompt: &optimized_prompt,
            stream: true,
        };
    }
}
```

### 2.3 æµå¼å“åº”å¤„ç†
æ‰€æœ‰AIæœåŠ¡éƒ½æ”¯æŒæµå¼å“åº”ï¼Œæä¾›å®æ—¶åé¦ˆï¼š

```rust
// ä¼˜åŒ–çš„æµå¤„ç†ï¼šé¢„åˆ†é…ç¼“å†²åŒºï¼Œå‡å°‘å†…å­˜é‡æ–°åˆ†é…
let mut message = String::with_capacity(2048);
let mut stdout_handle = stdout();
let mut stream = res.bytes_stream();
let mut buffer = Vec::with_capacity(8192);

while let Some(item) = stream.next().await {
    let chunk = item?;
    buffer.extend_from_slice(&chunk);
    
    // æ‰¹é‡å¤„ç†ç¼“å†²åŒºä¸­çš„æ•°æ®
    if buffer.len() > 4096 {
        process_chunk(&buffer, &mut message, &mut stdout_handle).await?;
        buffer.clear();
    }
}
```

## 3. Git Worktreeç®¡ç†ç³»ç»Ÿ

### 3.1 å®Œæ•´çš„å·¥ä½œæ ‘æ“ä½œ

#### åˆ›å»ºå·¥ä½œæ ‘
```bash
# ä¸ºç°æœ‰åˆ†æ”¯åˆ›å»ºå·¥ä½œæ ‘
ai-commit --worktree-create feature/existing-branch

# åˆ›å»ºæ–°åˆ†æ”¯çš„å·¥ä½œæ ‘
ai-commit --worktree-create feature/new-branch

# æŒ‡å®šè‡ªå®šä¹‰è·¯å¾„
ai-commit --worktree-create feature/auth --worktree-path ~/dev/auth-feature
```

**è‡ªåŠ¨è·¯å¾„ç”Ÿæˆè§„åˆ™**ï¼š
```rust
let path = if let Some(custom) = custom_path {
    PathBuf::from(custom)
} else {
    let current_dir = std::env::current_dir()?;
    let parent_dir = current_dir.parent().unwrap();
    let branch_name = branch.replace('/', "-");
    parent_dir.join(format!("worktree-{}", branch_name))
};
```

#### åˆ—å‡ºå·¥ä½œæ ‘
```bash
# åŸºç¡€åˆ—è¡¨
ai-commit --worktree-list

# è¯¦ç»†æ¨¡å¼ï¼ˆç­‰åŒäºgit worktree list -vï¼‰
ai-commit --worktree-list --worktree-verbose

# æœºå™¨å¯è¯»æ ¼å¼ï¼ˆç­‰åŒäºgit worktree list --porcelainï¼‰
ai-commit --worktree-list --worktree-porcelain

# ä½¿ç”¨NULå­—ç¬¦åˆ†éš”ï¼ˆç­‰åŒäºgit worktree list -zï¼‰
ai-commit --worktree-list --worktree-z

# æ˜¾ç¤ºè¿‡æœŸæ—¶é—´æ³¨é‡Š
ai-commit --worktree-list --worktree-expire 2weeks
```

#### å·¥ä½œæ ‘ä¿¡æ¯ç»“æ„
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorktreeInfo {
    pub path: PathBuf,      // å·¥ä½œæ ‘è·¯å¾„
    pub branch: String,     // åˆ†æ”¯åç§°
    pub commit: String,     // æäº¤å“ˆå¸Œ
    pub is_bare: bool,      // æ˜¯å¦ä¸ºè£¸ä»“åº“
    pub is_detached: bool,  // æ˜¯å¦ä¸ºåˆ†ç¦»HEAD
}
```

#### åˆ‡æ¢å’Œåˆ é™¤å·¥ä½œæ ‘
```bash
# æ™ºèƒ½åˆ‡æ¢ï¼ˆæ”¯æŒåˆ†æ”¯åã€è·¯å¾„ã€éƒ¨åˆ†åŒ¹é…ï¼‰
ai-commit --worktree-switch feature/ui
ai-commit --worktree-switch worktree-feature-ui

# åˆ é™¤æŒ‡å®šå·¥ä½œæ ‘
ai-commit --worktree-remove feature/old-feature

# æ‰¹é‡æ¸…ç†å…¶ä»–å·¥ä½œæ ‘
ai-commit --worktree-clear
```

### 3.2 å·¥ä½œæ ‘ç®¡ç†çš„é«˜çº§ç‰¹æ€§

#### æ™ºèƒ½åŒ¹é…ç®—æ³•
```rust
let target_worktree = worktrees
    .iter()
    .find(|w| {
        w.path.to_string_lossy().contains(path_or_name)
            || w.branch.contains(path_or_name)
            || w.path
                .file_name()
                .is_some_and(|f| f.to_string_lossy().contains(path_or_name))
    })
    .ok_or_else(|| anyhow::anyhow!("æ‰¾ä¸åˆ°æŒ‡å®šçš„ worktree: {}", path_or_name))?;
```

#### æ‰¹é‡æ¸…ç†åŠŸèƒ½
```rust
pub async fn clear_other_worktrees() -> anyhow::Result<usize> {
    let current_dir = std::env::current_dir()?;
    let worktrees = list_worktrees().await?;
    
    // æ‰¾åˆ°å½“å‰å·¥ä½œç›®å½•æ‰€å±çš„worktree
    let current_worktree = worktrees
        .iter()
        .find(|w| w.path == current_dir || current_dir.starts_with(&w.path));
    
    let mut removed_count = 0;
    
    // åˆ é™¤é™¤å½“å‰å¤–çš„æ‰€æœ‰å…¶ä»–worktrees
    for worktree in &worktrees {
        if worktree.path != current_path && !worktree.is_bare {
            // ä½¿ç”¨--forceå¼ºåˆ¶åˆ é™¤
            match Command::new("git")
                .args(["worktree", "remove", "--force", &path_str])
                .status()
                .await
            {
                Ok(status) if status.success() => removed_count += 1,
                _ => { /* è®°å½•å¤±è´¥ä½†ç»§ç»­å¤„ç†å…¶ä»–å·¥ä½œæ ‘ */ }
            }
        }
    }
    
    // æ¸…ç†æ— æ•ˆçš„worktreeå¼•ç”¨
    prune_worktrees().await?;
    
    Ok(removed_count)
}
```

## 4. æ™ºèƒ½æ ‡ç­¾ç®¡ç†ç³»ç»Ÿ

### 4.1 è¯­ä¹‰åŒ–ç‰ˆæœ¬ç®¡ç†
æ”¯æŒå®Œæ•´çš„SemVerï¼ˆè¯­ä¹‰åŒ–ç‰ˆæœ¬ï¼‰è§„èŒƒï¼š

```bash
# è‡ªåŠ¨é€’å¢è¡¥ä¸ç‰ˆæœ¬ï¼ˆ1.0.0 â†’ 1.0.1ï¼‰
ai-commit --new-tag

# æŒ‡å®šå¤§ç‰ˆæœ¬ï¼ˆè‡ªåŠ¨ä».0å¼€å§‹æŸ¥æ‰¾å¯ç”¨ç‰ˆæœ¬ï¼‰
ai-commit --new-tag v2.0.0

# æŒ‡å®šå®Œæ•´ç‰ˆæœ¬ï¼ˆå†²çªæ—¶è‡ªåŠ¨é€’å¢ï¼‰
ai-commit --new-tag v1.2.3
```

### 4.2 ç‰ˆæœ¬è§£æå’Œé€’å¢é€»è¾‘
```rust
async fn resolve_next_tag_name(base_version: Option<&str>) -> anyhow::Result<String> {
    let all_tags = get_all_tags().await?;
    
    let base_version = base_version.and_then(|v| {
        let trimmed = v.trim_start_matches('v');
        if trimmed.is_empty() { None } else { Some(trimmed) }
    });
    
    let mut parts: Vec<u32>;
    
    if let Some(base) = base_version {
        // ç”¨æˆ·æŒ‡å®šäº†åŸºç¡€ç‰ˆæœ¬
        parts = base.split('.').filter_map(|s| u32::from_str(s).ok()).collect();
        if parts.len() == 2 { parts.push(0); } // è¡¥å……patchç‰ˆæœ¬
    } else {
        // ä»æœ€æ–°æ ‡ç­¾é€’å¢
        let latest_tag_str = get_latest_tag_version().await
            .unwrap_or_else(|| "v0.0.0".to_string());
        let base = latest_tag_str.trim_start_matches('v');
        parts = base.split('.').filter_map(|s| u32::from_str(s).ok()).collect();
        parts[2] += 1; // é€’å¢patchç‰ˆæœ¬
    }
    
    // å¾ªç¯æŸ¥æ‰¾å¯ç”¨ç‰ˆæœ¬å·
    loop {
        let final_tag = format!("v{}.{}.{}", parts[0], parts[1], parts[2]);
        if !all_tags.contains(&final_tag) {
            return Ok(final_tag);
        }
        parts[2] += 1; // å†²çªæ—¶è‡ªåŠ¨é€’å¢
    }
}
```

### 4.3 æ ‡ç­¾ç¼“å­˜ä¼˜åŒ–
```rust
// ä½¿ç”¨å¼‚æ­¥Mutexç¼“å­˜æ ‡ç­¾åˆ—è¡¨
static TAGS_CACHE: Lazy<tokio::sync::Mutex<Option<HashSet<String>>>> =
    Lazy::new(|| tokio::sync::Mutex::new(None));

async fn get_all_tags() -> anyhow::Result<HashSet<String>> {
    // æ£€æŸ¥ç¼“å­˜
    {
        let cache = TAGS_CACHE.lock().await;
        if let Some(ref tags) = *cache {
            return Ok(tags.clone());
        }
    }
    
    // è·å–æ ‡ç­¾åˆ—è¡¨å¹¶æ›´æ–°ç¼“å­˜
    let output = Command::new("git").args(["tag", "-l"]).output().await?;
    let tags: HashSet<String> = String::from_utf8(output.stdout)?
        .lines()
        .map(|s| s.trim().to_owned())
        .filter(|s| !s.is_empty())
        .collect();
    
    // æ›´æ–°ç¼“å­˜
    *TAGS_CACHE.lock().await = Some(tags.clone());
    Ok(tags)
}
```

### 4.4 æ¨é€ç­–ç•¥æ§åˆ¶
```bash
# å®‰å…¨æ¨é€ï¼šä»…æ¨é€æ ‡ç­¾
ai-commit --new-tag --push

# æ‰¹é‡æ¨é€ï¼šåŒæ—¶æ¨é€å¸¸ç”¨åˆ†æ”¯å’Œæ ‡ç­¾
ai-commit --new-tag --push --push-branches
```

**æ¨é€é€»è¾‘**ï¼š
```rust
pub async fn push_tag(tag: &str, allow_push_branches: bool) -> anyhow::Result<()> {
    let mut push_args = vec!["push", "origin"];
    
    if allow_push_branches {
        // æ£€æŸ¥å¹¶æ·»åŠ å­˜åœ¨çš„åˆ†æ”¯
        let existing_branches = get_existing_branches().await?;
        for branch in ["master", "develop", "main"] {
            if existing_branches.contains(branch) {
                push_args.push(branch);
            }
        }
    }
    
    push_args.push(tag);
    
    let status = Command::new("git").args(&push_args).status().await?;
    // å¤„ç†æ¨é€ç»“æœ...
}
```

## 5. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 5.1 HTTPå®¢æˆ·ç«¯ä¼˜åŒ–
```rust
// å…¨å±€HTTPå®¢æˆ·ç«¯å¤ç”¨
static HTTP_CLIENT: Lazy<Client> = Lazy::new(|| {
    Client::builder()
        .pool_max_idle_per_host(10)        // æœ€å¤§10ä¸ªç©ºé—²è¿æ¥
        .pool_idle_timeout(Duration::from_secs(30))  // 30ç§’è¶…æ—¶
        .build()
        .expect("Failed to create HTTP client")
});
```

### 5.2 æ­£åˆ™è¡¨è¾¾å¼é¢„ç¼–è¯‘
```rust
// é¢„ç¼–è¯‘éªŒè¯æ­£åˆ™è¡¨è¾¾å¼ï¼Œæå‡æ€§èƒ½
static INVALID_RESPONSE_PATTERNS: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?i)(\{\{git_diff\}\}|è¾“å‡ºæ ¼å¼|git diff:|these are|here's a)")
        .unwrap()
});

static VALID_COMMIT_FORMAT: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"^(feat|fix|docs|style|refactor|test|chore)(\([^)]+\))?:\s+\S+.*$")
        .unwrap()
});
```

### 5.3 å†…å­˜ç®¡ç†ä¼˜åŒ–
```rust
// é¢„åˆ†é…ç¼“å†²åŒºï¼Œå‡å°‘å†…å­˜é‡æ–°åˆ†é…
let mut message = String::with_capacity(2048);  // é¢„åˆ†é…å­—ç¬¦ä¸²ç¼“å†²åŒº
let mut buffer = Vec::with_capacity(8192);      // é¢„åˆ†é…å­—èŠ‚ç¼“å†²åŒº

// æ‰¹é‡å¤„ç†é˜ˆå€¼
if buffer.len() > 4096 {
    process_chunk(&buffer).await?;
    buffer.clear();  // åŠæ—¶é‡Šæ”¾å†…å­˜
}
```

### 5.4 Gitæ“ä½œä¼˜åŒ–
```rust
// å¹¶è¡Œæ‰§è¡Œå¤šä¸ªGitå‘½ä»¤
pub async fn git_status_and_diff() -> anyhow::Result<(String, String)> {
    let (status_result, diff_result) = tokio::join!(
        Command::new("git").args(["status", "--porcelain"]).output(),
        Command::new("git").args(["diff", "--cached"]).output()
    );
    // å¤„ç†ç»“æœ...
}
```

## 6. é…ç½®ç®¡ç†ç³»ç»Ÿ

### 6.1 å¤šå±‚çº§é…ç½®æ¶æ„
```rust
pub struct Config {
    pub provider: String,
    pub model: String,
    pub deepseek_api_key: Option<String>,
    pub deepseek_url: String,
    pub ollama_url: String,
    pub siliconflow_api_key: Option<String>,
    pub siliconflow_url: String,
    pub debug: bool,
}

impl Config {
    pub fn new() -> Self {
        let mut config = Config::default();
        config.load_from_env();  // åŠ è½½ç¯å¢ƒå˜é‡
        config
    }
    
    pub fn update_from_args(&mut self, args: &Args) {
        // å‘½ä»¤è¡Œå‚æ•°ä¼˜å…ˆçº§æœ€é«˜
        if !args.provider.is_empty() {
            self.provider = args.provider.clone();
        }
        if !args.model.is_empty() {
            self.model = args.model.clone();
        }
    }
}
```

### 6.2 ç¯å¢ƒå˜é‡ç¼“å­˜æœºåˆ¶
```rust
// å…¨å±€ç¯å¢ƒå˜é‡ç¼“å­˜
static ENV_VARS_CACHE: Lazy<std::sync::Mutex<Option<EnvVars>>> =
    Lazy::new(|| std::sync::Mutex::new(None));

impl EnvVars {
    fn load() -> Self {
        // æ£€æŸ¥ç¼“å­˜
        {
            let cache = ENV_VARS_CACHE.lock().unwrap();
            if let Some(ref cached_vars) = *cache {
                return cached_vars.clone();
            }
        }
        
        // æ‰¹é‡è¯»å–ç¯å¢ƒå˜é‡
        let vars = Self {
            provider: env::var("AI_COMMIT_PROVIDER").ok(),
            model: env::var("AI_COMMIT_MODEL").ok(),
            deepseek_api_key: env::var("AI_COMMIT_DEEPSEEK_API_KEY").ok(),
            // ... å…¶ä»–å˜é‡
        };
        
        // æ›´æ–°ç¼“å­˜
        *ENV_VARS_CACHE.lock().unwrap() = Some(vars.clone());
        vars
    }
}
```

### 6.3 é…ç½®éªŒè¯ç³»ç»Ÿ
```rust
pub fn validate(&self) -> anyhow::Result<()> {
    match self.provider.as_str() {
        "deepseek" => {
            if self.deepseek_api_key.is_none() {
                anyhow::bail!("Deepseek API key is required but not set. Please set AI_COMMIT_DEEPSEEK_API_KEY environment variable");
            }
        }
        "siliconflow" => {
            if self.siliconflow_api_key.is_none() {
                anyhow::bail!("SiliconFlow API key is required but not set. Please set AI_COMMIT_SILICONFLOW_API_KEY environment variable");
            }
        }
        "ollama" => {
            // Ollamaä½¿ç”¨æœ¬åœ°æœåŠ¡ï¼Œä¸éœ€è¦API key
        }
        _ => {
            anyhow::bail!("Unsupported provider: {}", self.provider);
        }
    }
    Ok(())
}
```

## 7. å›½é™…åŒ–æ”¯æŒ

### 7.1 å¤šè¯­è¨€æ”¯æŒ
```rust
pub enum Language {
    ZhCn,  // ç®€ä½“ä¸­æ–‡
    ZhTw,  // ç¹ä½“ä¸­æ–‡
    En,    // è‹±è¯­
}

pub fn get_message(key: &str, lang: Language) -> &'static str {
    match (key, lang) {
        ("git_repo_not_found", Language::ZhCn) => "æœªæ‰¾åˆ°Gitä»“åº“",
        ("git_repo_not_found", Language::ZhTw) => "æœªæ‰¾åˆ°Gitå€‰åº«",
        ("git_repo_not_found", Language::En) => "Git repository not found",
        // ... æ›´å¤šæ¶ˆæ¯
    }
}
```

### 7.2 åŠ¨æ€è¯­è¨€åˆ‡æ¢
```bash
# é€šè¿‡ç¯å¢ƒå˜é‡è®¾ç½®è¯­è¨€
AI_COMMIT_LANGUAGE=en ai-commit --help

# é€šè¿‡é…ç½®æ–‡ä»¶è®¾ç½®
echo "AI_COMMIT_LANGUAGE=zh-tw" >> ~/.ai-commit/.env
```

## 8. æ™ºèƒ½æäº¤ä¿¡æ¯ä¼˜åŒ–ç³»ç»Ÿ

### 8.1 è‡ªåŠ¨é•¿åº¦æ£€æµ‹ä¸äºŒæ¬¡ç”Ÿæˆ

AI-Commit å†…ç½®äº†æ™ºèƒ½çš„æäº¤ä¿¡æ¯ä¼˜åŒ–ç³»ç»Ÿï¼Œèƒ½å¤Ÿè‡ªåŠ¨æ£€æµ‹è¿‡é•¿çš„æäº¤ä¿¡æ¯å¹¶è¿›è¡Œä¼˜åŒ–å¤„ç†ï¼š

**è§¦å‘æ¡ä»¶**ï¼š
- ç”Ÿæˆçš„ commit message è¶…è¿‡ 100 å­—ç¬¦æ—¶è‡ªåŠ¨è§¦å‘
- æ”¯æŒæ‰€æœ‰ AI æä¾›å•†ï¼ˆOllamaã€Deepseekã€SiliconFlowï¼‰

**ä¼˜åŒ–æµç¨‹**ï¼š
```rust
// æ£€æŸ¥é•¿åº¦ï¼ˆåŸºäºå­—ç¬¦æ•°ï¼Œä¸æ˜¯å­—èŠ‚æ•°ï¼‰
if first_line.chars().count() > 100 {
    if config.debug {
        println!(
            "åˆå§‹æäº¤ä¿¡æ¯è¿‡é•¿ï¼ˆ{}å­—ç¬¦ï¼‰ï¼Œå¯åŠ¨äºŒæ¬¡ç”Ÿæˆä¼˜åŒ–...",
            first_line.chars().count()
        );
    }
    
    // è¿›è¡ŒäºŒæ¬¡ç”Ÿæˆï¼Œç”Ÿæˆæ›´ç®€æ´çš„ç‰ˆæœ¬
    let optimized_message = generate_optimized_commit_message(
        &message, 
        config, 
        &optimized_prompt,
        &config.provider
    ).await?;
    return Ok(optimized_message);
}
```

### 8.2 æ™ºèƒ½ä¼˜åŒ–ç­–ç•¥

**ä¼˜åŒ–æç¤ºè¯æ¨¡æ¿**ï¼š
```text
è¾“å‡ºæ ¼å¼ï¼š<type>(<scope>): <subject>

type: feat|fix|docs|style|refactor|test|chore
subject: ä¸­æ–‡ï¼Œä¸è¶…è¿‡50å­—ï¼Œç®€æ´æ˜äº†

ä¼˜åŒ–ä»»åŠ¡ï¼šå°†ä»¥ä¸‹è¿‡é•¿çš„æäº¤ä¿¡æ¯å‹ç¼©ä¸ºç¬¦åˆè§„èŒƒçš„ç®€æ´ç‰ˆæœ¬

åŸå§‹ä¿¡æ¯ï¼š{original_message}

ä¼˜åŒ–è¦æ±‚ï¼š
- ä¿ç•™æ ¸å¿ƒå˜æ›´ç±»å‹ï¼ˆfeat/fix/refactorç­‰ï¼‰
- ä¿ç•™ä¸»è¦ä½œç”¨åŸŸ
- ç²¾ç®€ä¸»é¢˜æè¿°ï¼Œå»é™¤å†—ä½™è¯æ±‡
- çªå‡ºæœ€å…³é”®çš„å˜æ›´ç‚¹
- å­—ç¬¦æ•°æ§åˆ¶åœ¨50å­—ä»¥å†…

æ­£ç¡®ç¤ºä¾‹ï¼š
feat(ai): ä¼˜åŒ–å“åº”å¤„ç†å’ŒéªŒè¯é€»è¾‘
fix(auth): ä¿®å¤ç™»å½•è¶…æ—¶é—®é¢˜
refactor(core): ç®€åŒ–é…ç½®ç®¡ç†æ¨¡å—
```

### 8.3 æ™ºèƒ½æˆªæ–­åå¤‡æœºåˆ¶

å½“ AI äºŒæ¬¡ç”Ÿæˆå¤±è´¥æ—¶ï¼Œç³»ç»Ÿä½¿ç”¨æ™ºèƒ½æˆªæ–­ç®—æ³•ï¼š

```rust
fn generate_fallback_message(original_line: &str) -> anyhow::Result<String> {
    // è§£æåŸå§‹æ¶ˆæ¯çš„ç»„æˆéƒ¨åˆ†
    if let Some(caps) = VALID_COMMIT_FORMAT.captures(original_line) {
        let commit_type = caps.get(1).map(|m| m.as_str()).unwrap_or("refactor");
        let scope = caps.get(2).map(|m| m.as_str()).unwrap_or("");
        
        // æ™ºèƒ½æˆªæ–­ï¼Œä¿ç•™å…³é”®è¯
        let key_words = ["æ·»åŠ ", "ä¿®å¤", "æ›´æ–°", "åˆ é™¤", "é‡æ„", "ä¼˜åŒ–", "å®ç°", "æ”¯æŒ"];
        // ä¿ç•™åŒ…å«å…³é”®è¯çš„éƒ¨åˆ†ï¼Œæˆªæ–­åˆ°åˆé€‚é•¿åº¦
    }
}
```

**å…³é”®è¯ä¼˜å…ˆä¿ç•™**ï¼š
- æ ¸å¿ƒåŠ¨ä½œè¯ï¼šæ·»åŠ ã€ä¿®å¤ã€æ›´æ–°ã€åˆ é™¤ã€é‡æ„ã€ä¼˜åŒ–ã€å®ç°ã€æ”¯æŒ
- æ™ºèƒ½æˆªæ–­ï¼šä¼˜å…ˆä¿ç•™åŒ…å«å…³é”®è¯çš„è¯æ±‡
- é•¿åº¦æ§åˆ¶ï¼šç¡®ä¿æœ€ç»ˆç»“æœä¸è¶…è¿‡ 50 å­—ç¬¦

### 8.4 è°ƒè¯•æ¨¡å¼æ”¯æŒ

```bash
# å¼€å¯è°ƒè¯•æ¨¡å¼æŸ¥çœ‹ä¼˜åŒ–è¿‡ç¨‹
$ AI_COMMIT_DEBUG=true ai-commit

# è¾“å‡ºç¤ºä¾‹ï¼š
åˆå§‹æäº¤ä¿¡æ¯è¿‡é•¿ï¼ˆ78å­—ç¬¦ï¼‰ï¼Œå¯åŠ¨äºŒæ¬¡ç”Ÿæˆä¼˜åŒ–...
âœ… äºŒæ¬¡ä¼˜åŒ–æˆåŠŸ: 'feat(ai): ä¼˜åŒ–å“åº”å¤„ç†å’ŒéªŒè¯é€»è¾‘' (18 å­—ç¬¦)
```

**è°ƒè¯•ä¿¡æ¯åŒ…å«**ï¼š
- åŸå§‹æ¶ˆæ¯é•¿åº¦æ£€æµ‹
- äºŒæ¬¡ä¼˜åŒ–å¯åŠ¨æç¤º
- ä¼˜åŒ–ç»“æœéªŒè¯
- æœ€ç»ˆæ¶ˆæ¯å’Œå­—ç¬¦æ•°ç»Ÿè®¡

### 8.5 æ€§èƒ½ä¼˜åŒ–

**éæµå¼è¯·æ±‚**ï¼š
- äºŒæ¬¡ç”Ÿæˆä½¿ç”¨éæµå¼è¯·æ±‚ï¼ˆ`stream: false`ï¼‰
- æ›´å¿«çš„å“åº”æ—¶é—´ï¼Œå‡å°‘å»¶è¿Ÿ
- é¿å…æµå¼å¤„ç†çš„é¢å¤–å¼€é”€

**ç¼“å­˜å¤ç”¨**ï¼š
- å¤ç”¨å…¨å±€ HTTP å®¢æˆ·ç«¯
- é¢„ç¼–è¯‘çš„æ­£åˆ™è¡¨è¾¾å¼éªŒè¯
- å‡å°‘é‡å¤åˆ›å»ºå¯¹è±¡çš„å¼€é”€

**é”™è¯¯å¤„ç†**ï¼š
- å®Œæ•´çš„é”™è¯¯é“¾å¤„ç†
- ä¼˜é›…çš„é™çº§åˆ°æ™ºèƒ½æˆªæ–­
- ç¡®ä¿æ€»æ˜¯è¿”å›æœ‰æ•ˆçš„æäº¤ä¿¡æ¯

## 9. æ™ºèƒ½ä»£ç å®¡æŸ¥ç³»ç»Ÿ

### 9.1 å¤šè¯­è¨€ä»£ç åˆ†æå¼•æ“

AI-Commit å†…ç½®äº†æ™ºèƒ½ä»£ç å®¡æŸ¥ç³»ç»Ÿï¼Œæ”¯æŒå¯¹å¤šç§ç¼–ç¨‹è¯­è¨€è¿›è¡Œæ·±åº¦åˆ†æï¼š

**æ”¯æŒçš„ç¼–ç¨‹è¯­è¨€ï¼š**
- **Rust**: å‡½æ•°ã€ç»“æ„ä½“ã€æšä¸¾ã€traitã€impl å—ã€æ¨¡å—ã€use è¯­å¥ã€å¸¸é‡ã€é™æ€å˜é‡ã€ç±»å‹åˆ«å
- **Go**: åŒ…å£°æ˜ã€å‡½æ•°ã€æ–¹æ³•ã€ç»“æ„ä½“ã€æ¥å£ã€å¯¼å…¥ã€å¸¸é‡ã€å˜é‡
- **JavaScript**: å‡½æ•°ã€ç±»ã€å¯¼å…¥/requireã€å¯¼å‡ºã€ç®­å¤´å‡½æ•°ã€å˜é‡å£°æ˜
- **TypeScript**: æ¥å£ã€ç±»ã€å‡½æ•°ã€ç±»å‹åˆ«åã€æšä¸¾ã€å¯¼å…¥/å¯¼å‡ºã€æ–¹æ³•
- **Generic**: é€šç”¨è¯­è¨€ç‰¹å¾æ£€æµ‹ï¼ˆé€‚ç”¨äºæœªæ˜ç¡®æ”¯æŒçš„è¯­è¨€ï¼‰

### 8.2 è¯­è¨€ç‰¹å®šåˆ†æå™¨æ¶æ„

```rust
pub trait LanguageAnalyzer {
    fn language(&self) -> Language;
    fn analyze_line(&self, line: &str, line_number: usize) -> Vec<LanguageFeature>;
    fn extract_scope_suggestions(&self, file_path: &str) -> Vec<String>;
    fn analyze_change_patterns(&self, features: &[LanguageFeature]) -> Vec<String>;
    fn generate_test_suggestions(&self, features: &[LanguageFeature]) -> Vec<String>;
    fn assess_risks(&self, features: &[LanguageFeature]) -> Vec<String>;
    
    fn analyze_file_changes(
        &self,
        file_path: &str,
        added_lines: &[String],
    ) -> LanguageAnalysisResult {
        // é»˜è®¤å®ç°ï¼šé€è¡Œåˆ†æå¹¶èšåˆç»“æœ
        let mut features = Vec::new();
        for (index, line) in added_lines.iter().enumerate() {
            let line_features = self.analyze_line(line, index + 1);
            features.extend(line_features);
        }
        
        LanguageAnalysisResult {
            language: self.language(),
            features,
            scope_suggestions: self.extract_scope_suggestions(file_path),
            change_patterns: self.analyze_change_patterns(&features),
        }
    }
}
```

### 8.3 Rust è¯­è¨€ä¸“ç”¨åˆ†æå™¨

```rust
// Rust ç‰¹å®šçš„æ­£åˆ™è¡¨è¾¾å¼é¢„ç¼–è¯‘
static RUST_FN_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"^\s*(?:pub\s+)?(?:async\s+)?(?:unsafe\s+)?fn\s+(\w+)").unwrap());
static RUST_STRUCT_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"^\s*(?:pub\s+)?struct\s+(\w+)").unwrap());
static RUST_TRAIT_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"^\s*(?:pub\s+)?trait\s+(\w+)").unwrap());

impl LanguageAnalyzer for RustAnalyzer {
    fn analyze_line(&self, line: &str, line_number: usize) -> Vec<LanguageFeature> {
        let mut features = Vec::new();
        let trimmed_line = line.trim();
        
        // å‡½æ•°æ£€æµ‹ï¼ˆæ”¯æŒ pubã€asyncã€unsafe ä¿®é¥°ç¬¦ï¼‰
        if let Some(caps) = RUST_FN_REGEX.captures(trimmed_line) {
            let func_name = caps.get(1).map(|m| m.as_str()).unwrap_or("unknown");
            let attributes = self.analyze_function_attributes(trimmed_line);
            
            features.push(LanguageFeature {
                feature_type: "function".to_string(),
                name: func_name.to_string(),
                line_number: Some(line_number),
                description: format!("Rust function definition ({})", attributes.join(", ")),
            });
        }
        
        // Trait æ£€æµ‹
        if let Some(caps) = RUST_TRAIT_REGEX.captures(trimmed_line) {
            features.push(LanguageFeature {
                feature_type: "trait".to_string(),
                name: caps.get(1).map(|m| m.as_str()).unwrap_or("unknown").to_string(),
                line_number: Some(line_number),
                description: "Rust trait definition for shared behavior".to_string(),
            });
        }
        
        features
    }
    
    fn assess_risks(&self, features: &[LanguageFeature]) -> Vec<String> {
        let mut risks = Vec::new();
        
        // æ£€æŸ¥ unsafe ä»£ç é£é™©
        if features.iter().any(|f| f.description.contains("unsafe")) {
            risks.push("Unsafeä»£ç å˜æ›´éœ€è¦é¢å¤–å…³æ³¨å†…å­˜å®‰å…¨å’Œæœªå®šä¹‰è¡Œä¸º".to_string());
        }
        
        // æ£€æŸ¥å…¬å…±APIå˜æ›´é£é™©
        for feature in features {
            if feature.description.contains("public") {
                match feature.feature_type.as_str() {
                    "function" | "struct" | "enum" | "trait" => {
                        risks.push(format!(
                            "å…¬å…± {} {} çš„å˜æ›´å¯èƒ½ç ´åAPIå…¼å®¹æ€§",
                            feature.feature_type, feature.name
                        ));
                    }
                    _ => {}
                }
            }
        }
        
        risks
    }
}
```

### 8.4 Go è¯­è¨€ä¸“ç”¨åˆ†æå™¨

```rust
// Go ç‰¹å®šçš„æ­£åˆ™è¡¨è¾¾å¼
static GO_FUNC_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^\s*func\s+(\w*\s*)?\(").unwrap());
static GO_STRUCT_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^\s*type\s+(\w+)\s+struct").unwrap());
static GO_INTERFACE_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^\s*type\s+(\w+)\s+interface").unwrap());
static GO_METHOD_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^\s*func\s+\([^)]+\)\s+(\w+)").unwrap());

impl LanguageAnalyzer for GoAnalyzer {
    fn analyze_change_patterns(&self, features: &[LanguageFeature]) -> Vec<String> {
        let mut patterns = Vec::new();
        
        if features.iter().any(|f| f.feature_type == "interface") {
            patterns.push("æ¥å£å®šä¹‰å˜æ›´ï¼Œå¯èƒ½å½±å“å¤šä¸ªå®ç°ç±»å‹".to_string());
        }
        
        if features.iter().any(|f| f.feature_type == "method") {
            patterns.push("æ–¹æ³•å®šä¹‰å˜æ›´ï¼Œéœ€è¦æ£€æŸ¥æ¥æ”¶è€…ç±»å‹å’Œè°ƒç”¨è€…".to_string());
        }
        
        patterns
    }
    
    fn generate_test_suggestions(&self, features: &[LanguageFeature]) -> Vec<String> {
        let mut suggestions = vec![
            "åˆ›å»ºå¯¹åº”çš„ *_test.go æµ‹è¯•æ–‡ä»¶".to_string(),
            "ä½¿ç”¨è¡¨é©±åŠ¨æµ‹è¯•æ–¹æ³•æé«˜æµ‹è¯•è¦†ç›–ç‡".to_string(),
            "è¿è¡Œ go test ./... æ‰§è¡Œæ‰€æœ‰æµ‹è¯•".to_string(),
        ];
        
        // é’ˆå¯¹æ¥å£å˜æ›´çš„ç‰¹æ®Šå»ºè®®
        if features.iter().any(|f| f.feature_type == "interface") {
            suggestions.push("ä¸ºæ¥å£çš„æ‰€æœ‰å®ç°åˆ›å»ºæµ‹è¯•ç”¨ä¾‹".to_string());
            suggestions.push("ä½¿ç”¨ go test -race æ£€æŸ¥å¹¶å‘å®‰å…¨æ€§".to_string());
        }
        
        suggestions
    }
}
```

### 8.5 ä»£ç å®¡æŸ¥æŠ¥å‘Šç”Ÿæˆ

#### æŠ¥å‘Šç»“æ„å®šä¹‰
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct CodeReviewReport {
    pub summary: ReviewSummary,
    pub files: Vec<FileAnalysisResult>,
    pub generated_at: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ReviewSummary {
    pub total_files: usize,
    pub total_features: usize,
    pub languages_detected: std::collections::HashMap<Language, usize>,
    pub common_patterns: Vec<String>,
    pub overall_risks: Vec<String>,
    pub test_suggestions: Vec<String>,
}
```

#### æ™ºèƒ½è¾“å‡ºç³»ç»Ÿ
```rust
impl CodeReviewService {
    /// æ ¼å¼åŒ–æŠ¥å‘Šä¸ºå¯è¯»æ–‡æœ¬ï¼Œæ”¯æŒå†…å®¹é•¿åº¦ä¼˜åŒ–
    pub fn format_report(&self, report: &CodeReviewReport) -> String {
        let initial_report = self.format_report_internal(report, false);
        
        // æ£€æŸ¥æŠ¥å‘Šé•¿åº¦æ˜¯å¦è¿‡é•¿ï¼ˆè¶…è¿‡ 10000 å­—ç¬¦ï¼‰
        if initial_report.len() > 10000 {
            // ç”Ÿæˆä¼˜åŒ–ç‰ˆæœ¬çš„æŠ¥å‘Š
            self.format_report_internal(report, true)
        } else {
            initial_report
        }
    }
    
    /// å†…éƒ¨æ ¼å¼åŒ–æ–¹æ³•ï¼Œæ”¯æŒä¼˜åŒ–æ¨¡å¼
    fn format_report_internal(&self, report: &CodeReviewReport, optimize: bool) -> String {
        // ä¼˜åŒ–æ¨¡å¼ä¸‹é™åˆ¶æ˜¾ç¤ºæ•°é‡ï¼š
        // - å˜æ›´æ¨¡å¼ï¼šå‰5ä¸ª + çœç•¥æç¤º
        // - é£é™©è¯„ä¼°ï¼šå‰5ä¸ª + çœç•¥æç¤º
        // - æµ‹è¯•å»ºè®®ï¼šå‰8ä¸ª + çœç•¥æç¤º
        // - æ–‡ä»¶åˆ†æï¼šå‰10ä¸ªæ–‡ä»¶ + çœç•¥æç¤º
        // - æ¯ä¸ªæ–‡ä»¶ç‰¹å¾ï¼šå‰5ä¸ª + çœç•¥æç¤º
        // - ä½œç”¨åŸŸå»ºè®®ï¼šå‰3ä¸ª + çœç•¥æç¤º
    }
}
```

**æ™ºèƒ½ä¼˜åŒ–ç‰¹æ€§ï¼š**
- **è‡ªåŠ¨æ£€æµ‹**ï¼šå½“æŠ¥å‘Šå†…å®¹è¶…è¿‡10,000å­—ç¬¦æ—¶è‡ªåŠ¨è§¦å‘ä¼˜åŒ–
- **æ¸è¿›å¼è£å‰ª**ï¼šä¼˜å…ˆä¿ç•™æœ€é‡è¦çš„ä¿¡æ¯ï¼Œé€çº§è£å‰ªè¯¦ç»†å†…å®¹
- **æ˜ç¡®æç¤º**ï¼šæ˜¾ç¤ºçœç•¥çš„å†…å®¹æ•°é‡ï¼Œæä¾›å®Œæ•´æ•°æ®è·å–å»ºè®®
- **æ— æŸæ›¿ä»£**ï¼šå»ºè®®ä½¿ç”¨JSONæ ¼å¼è·å–å®Œæ•´åˆ†ææ•°æ®
- **ç”¨æˆ·å‹å¥½**ï¼šåœ¨ä¿æŒå¯è¯»æ€§çš„åŒæ—¶æ§åˆ¶æŠ¥å‘Šé•¿åº¦
    
    fn format_as_markdown(&self, report: &CodeReviewReport) -> String {
        let mut output = String::new();
        
        output.push_str("# ä»£ç å®¡æŸ¥æŠ¥å‘Š\n\n");
        
        // æ‘˜è¦ç»Ÿè®¡
        output.push_str("## ğŸ“Š æ‘˜è¦ç»Ÿè®¡\n\n");
        output.push_str(&format!("- **æ€»æ–‡ä»¶æ•°**: {}\n", report.summary.total_files));
        output.push_str(&format!("- **æ£€æµ‹åˆ°çš„ç‰¹å¾æ•°**: {}\n", report.summary.total_features));
        output.push_str("- **æ£€æµ‹åˆ°çš„è¯­è¨€**:\n");
        
        for (language, count) in &report.summary.languages_detected {
            output.push_str(&format!("  - {}: {} ä¸ªæ–‡ä»¶\n", language.as_str(), count));
        }
        
        // å˜æ›´æ¨¡å¼åˆ†æ
        if !report.summary.common_patterns.is_empty() {
            output.push_str("\n## ğŸ” å˜æ›´æ¨¡å¼åˆ†æ\n\n");
            for pattern in &report.summary.common_patterns {
                output.push_str(&format!("- {}\n", pattern));
            }
        }
        
        // é£é™©è¯„ä¼°
        if !report.summary.overall_risks.is_empty() {
            output.push_str("\n## âš ï¸  é£é™©è¯„ä¼°\n\n");
            for risk in &report.summary.overall_risks {
                output.push_str(&format!("- {}\n", risk));
            }
        }
        
        // æµ‹è¯•å»ºè®®
        if !report.summary.test_suggestions.is_empty() {
            output.push_str("\n## ğŸ§ª æµ‹è¯•å»ºè®®\n\n");
            for suggestion in &report.summary.test_suggestions {
                output.push_str(&format!("- {}\n", suggestion));
            }
        }
        
        output
    }
}
```

### 8.6 è‡ªåŠ¨æ–‡ä»¶è¾“å‡ºåŠŸèƒ½

```rust
// å¤„ç†è¾“å‡ºé€»è¾‘ï¼ˆä¸»å‡½æ•°ä¸­ï¼‰
if let Some(output_file) = &args.review_output {
    // ç”¨æˆ·æŒ‡å®šäº†è¾“å‡ºæ–‡ä»¶
    std::fs::write(output_file, &formatted_report)?;
    println!("âœ… ä»£ç å®¡æŸ¥æŠ¥å‘Šå·²ä¿å­˜åˆ°: {}", output_file);
} else {
    // é»˜è®¤è¾“å‡ºåˆ° code-review ç›®å½•
    let code_review_dir = std::path::Path::new("code-review");
    
    // å¦‚æœç›®å½•ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºå®ƒ
    if !code_review_dir.exists() {
        std::fs::create_dir_all(code_review_dir)?;
    }
    
    // ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å
    let timestamp = Utc::now().format("%Y%m%d_%H%M%S").to_string();
    let extension = match args.review_format.as_str() {
        "json" => "json",
        "text" => "txt", 
        _ => "md", // markdown (default)
    };
    let filename = format!("review_{}.{}", timestamp, extension);
    let output_path = code_review_dir.join(filename);
    
    std::fs::write(&output_path, &formatted_report)?;
    println!("âœ… ä»£ç å®¡æŸ¥æŠ¥å‘Šå·²ä¿å­˜åˆ°: {}", output_path.display());
}
```

### 8.7 ä½¿ç”¨ç¤ºä¾‹

```bash
# åŸºæœ¬ä»£ç å®¡æŸ¥ï¼ˆè¾“å‡ºåˆ° code-review/review_20250102_143022.mdï¼‰
ai-commit --code-review

# JSON æ ¼å¼è¾“å‡ºï¼ˆç”¨äº CI/CD é›†æˆï¼‰
ai-commit --code-review --review-format json
# è¾“å‡ºï¼šcode-review/review_20250102_143022.json

# è‡ªå®šä¹‰è¾“å‡ºä½ç½®
ai-commit --code-review --review-output reports/daily-review.md

# å®¡æŸ¥ç‰¹å®šæ–‡ä»¶
ai-commit --code-review --review-files "src/main.rs,lib/auth.go"

# åªæ˜¾ç¤ºè¯­è¨€ç»Ÿè®¡
ai-commit --show-languages
# è¾“å‡ºï¼š
# ğŸ” æ£€æµ‹åˆ°çš„ç¼–ç¨‹è¯­è¨€:
#   rust : 5 ä¸ªæ–‡ä»¶
#   go : 3 ä¸ªæ–‡ä»¶
# ğŸ“Š æ€»è®¡: 8 ä¸ªæ–‡ä»¶, 42 ä¸ªä»£ç ç‰¹å¾
```

### 8.8 é›†æˆåˆ° CI/CD æµæ°´çº¿

```yaml
# GitHub Actions ç¤ºä¾‹
- name: Code Review Analysis
  run: |
    ai-commit --code-review --review-format json --review-output review-report.json
    
- name: Upload Review Report
  uses: actions/upload-artifact@v3
  with:
    name: code-review-report
    path: review-report.json
```

## 9. é”™è¯¯å¤„ç†ä¸è°ƒè¯•

### 8.1 ç»Ÿä¸€é”™è¯¯å¤„ç†
```rust
// ä½¿ç”¨anyhowè¿›è¡Œç»Ÿä¸€é”™è¯¯å¤„ç†
pub async fn generate_commit_message(
    diff: &str,
    config: &Config,
    prompt: &str,
) -> anyhow::Result<String> {
    // å„ç§å¯èƒ½çš„é”™è¯¯éƒ½ä¼šè¢«ç»Ÿä¸€å¤„ç†
    let response = make_request(client, url, api_key, &request).await
        .map_err(|e| anyhow::anyhow!("è¯·æ±‚å¤±è´¥: {e}"))?;
    
    if !response.status().is_success() {
        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        anyhow::bail!("å“åº”é”™è¯¯: çŠ¶æ€ç  {status}, å“åº”ä½“: {text}");
    }
    
    // ... å¤„ç†å“åº”
}
```

### 8.2 è°ƒè¯•æ¨¡å¼æ”¯æŒ
```bash
# å¯ç”¨è°ƒè¯•æ¨¡å¼
AI_COMMIT_DEBUG=true ai-commit

# è°ƒè¯•è¾“å‡ºç¤ºä¾‹
AI ç”Ÿæˆ commit message è€—æ—¶: 1.23s
æ£€æµ‹åˆ°å¤§å‹å˜æ›´ (6ä¸ªæ–‡ä»¶, 15234å­—ç¬¦)ï¼Œæ­£åœ¨ç”Ÿæˆæ‘˜è¦...
Created new tag: v1.0.1
Pushed tag v1.0.1 to remote
```

### 8.3 æ€§èƒ½ç›‘æ§
```rust
if config.debug {
    let start_time = Instant::now();
    let message = ai::generate_commit_message(diff, config, &prompt).await?;
    let elapsed_time = start_time.elapsed();
    
    println!("AI ç”Ÿæˆ commit message è€—æ—¶: {:.2?}", elapsed_time);
    
    if elapsed_time.as_secs() > 30 {
        println!("è­¦å‘Š: AI æ¨¡å‹ '{}' ç”Ÿæˆ commit message è€—æ—¶è¾ƒé•¿ï¼Œå»ºè®®æ›´æ¢æ›´å¿«çš„æ¨¡å‹", config.model);
    }
}
```

---

ä»¥ä¸Šè¯¦ç»†ä»‹ç»äº†AI-Commitçš„å„é¡¹åŠŸèƒ½ç‰¹æ€§å’ŒæŠ€æœ¯å®ç°ã€‚è¿™äº›åŠŸèƒ½çš„è®¾è®¡éƒ½å›´ç»•ç€æå‡ç”¨æˆ·ä½“éªŒã€ä¿è¯ä»£ç è´¨é‡å’Œä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½è¿™ä¸‰ä¸ªæ ¸å¿ƒç›®æ ‡ã€‚
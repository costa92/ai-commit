# AI-Commit 功能特性详解

## 1. 智能差异分析引擎

### 1.1 大文件智能处理
当检测到大型变更时，AI-Commit会自动启用智能摘要模式：

**触发条件**：
- 单次diff内容超过10,000字符
- 涉及文件数量超过5个

**处理策略**：
```rust
// 自动分析变更规模
let analysis = DiffAnalysis::analyze_diff(diff);

if analysis.is_large_diff || analysis.is_multi_file {
    // 生成摘要化提示词，避免文件名罗列
    let optimized_prompt = create_summarized_prompt(&analysis, diff, prompt);
}
```

**智能推断逻辑**：
- **变更类型推断**：基于文件变更模式自动推断commit类型
  - 新增文件 → `feat`
  - 测试文件变更 → `test`
  - 文档文件变更 → `docs`
  - 其他修改 → `refactor`

- **作用域推断**：基于文件路径智能推断scope
  - `src/ai/` → `ai`
  - `src/config/` → `config`
  - `tests/` → `test`
  - `docs/` → `docs`

**示例对比**：
```bash
# 传统方式（不推荐）
"修改src/ai/mod.rs、src/config/mod.rs、src/git/tag.rs等多个文件"

# 智能摘要（推荐）
"refactor(core): 重构模块架构提升性能和可维护性"
```

### 1.2 变更统计分析
```rust
pub struct DiffAnalysis {
    pub total_files: usize,        // 总文件数
    pub total_additions: usize,    // 总新增行数
    pub total_deletions: usize,    // 总删除行数
    pub file_changes: Vec<FileChange>,  // 详细文件变更
    pub is_large_diff: bool,       // 是否为大型变更
    pub is_multi_file: bool,       // 是否为多文件变更
    pub primary_change_type: String,   // 主要变更类型
    pub dominant_scope: Option<String>, // 主要作用域
}
```

## 2. 多AI服务提供商支持

### 2.1 支持的服务提供商

#### Ollama（本地服务，默认）
```bash
# 配置示例
AI_COMMIT_PROVIDER=ollama
AI_COMMIT_MODEL=mistral
AI_COMMIT_OLLAMA_URL=http://localhost:11434/api/generate
```

**特点**：
- ✅ 数据隐私性好（本地处理）
- ✅ 无API调用费用
- ✅ 支持多种开源模型
- ❌ 需要本地安装和配置
- ❌ 硬件要求较高

#### Deepseek（云端服务）
```bash
# 配置示例
AI_COMMIT_PROVIDER=deepseek
AI_COMMIT_MODEL=deepseek-chat
AI_COMMIT_DEEPSEEK_API_KEY=sk-your-key
AI_COMMIT_DEEPSEEK_URL=https://api.deepseek.com/v1/chat/completions
```

**特点**：
- ✅ 响应速度快
- ✅ 模型质量高
- ✅ 支持中文优化
- ❌ 需要API Key
- ❌ 有使用费用

#### SiliconFlow（云端服务）
```bash
# 配置示例
AI_COMMIT_PROVIDER=siliconflow
AI_COMMIT_MODEL=Qwen/Qwen2.5-7B-Instruct
AI_COMMIT_SILICONFLOW_API_KEY=sk-your-key
AI_COMMIT_SILICONFLOW_URL=https://api.siliconflow.cn/v1/chat/completions
```

**特点**：
- ✅ 模型选择丰富
- ✅ 支持最新模型
- ✅ 性价比较高
- ❌ 需要API Key
- ❌ 网络依赖

### 2.2 统一的API接口设计
```rust
// 统一的请求处理
match config.provider.as_str() {
    "siliconflow" | "deepseek" => {
        // 使用OpenAI兼容的API格式
        let request = DeepseekRequest {
            model: &config.model,
            messages: vec![DeepseekMessage {
                role: "user",
                content: &optimized_prompt,
            }],
            stream: true,
        };
    }
    _ => {
        // 使用Ollama原生API格式
        let request = OllamaRequest {
            model: &config.model,
            prompt: &optimized_prompt,
            stream: true,
        };
    }
}
```

### 2.3 流式响应处理
所有AI服务都支持流式响应，提供实时反馈：

```rust
// 优化的流处理：预分配缓冲区，减少内存重新分配
let mut message = String::with_capacity(2048);
let mut stdout_handle = stdout();
let mut stream = res.bytes_stream();
let mut buffer = Vec::with_capacity(8192);

while let Some(item) = stream.next().await {
    let chunk = item?;
    buffer.extend_from_slice(&chunk);
    
    // 批量处理缓冲区中的数据
    if buffer.len() > 4096 {
        process_chunk(&buffer, &mut message, &mut stdout_handle).await?;
        buffer.clear();
    }
}
```

## 3. Git Worktree管理系统

### 3.1 完整的工作树操作

#### 创建工作树
```bash
# 为现有分支创建工作树
ai-commit --worktree-create feature/existing-branch

# 创建新分支的工作树
ai-commit --worktree-create feature/new-branch

# 指定自定义路径
ai-commit --worktree-create feature/auth --worktree-path ~/dev/auth-feature
```

**自动路径生成规则**：
```rust
let path = if let Some(custom) = custom_path {
    PathBuf::from(custom)
} else {
    let current_dir = std::env::current_dir()?;
    let parent_dir = current_dir.parent().unwrap();
    let branch_name = branch.replace('/', "-");
    parent_dir.join(format!("worktree-{}", branch_name))
};
```

#### 列出工作树
```bash
# 基础列表
ai-commit --worktree-list

# 详细模式（等同于git worktree list -v）
ai-commit --worktree-list --worktree-verbose

# 机器可读格式（等同于git worktree list --porcelain）
ai-commit --worktree-list --worktree-porcelain

# 使用NUL字符分隔（等同于git worktree list -z）
ai-commit --worktree-list --worktree-z

# 显示过期时间注释
ai-commit --worktree-list --worktree-expire 2weeks
```

#### 工作树信息结构
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorktreeInfo {
    pub path: PathBuf,      // 工作树路径
    pub branch: String,     // 分支名称
    pub commit: String,     // 提交哈希
    pub is_bare: bool,      // 是否为裸仓库
    pub is_detached: bool,  // 是否为分离HEAD
}
```

#### 切换和删除工作树
```bash
# 智能切换（支持分支名、路径、部分匹配）
ai-commit --worktree-switch feature/ui
ai-commit --worktree-switch worktree-feature-ui

# 删除指定工作树
ai-commit --worktree-remove feature/old-feature

# 批量清理其他工作树
ai-commit --worktree-clear
```

### 3.2 工作树管理的高级特性

#### 智能匹配算法
```rust
let target_worktree = worktrees
    .iter()
    .find(|w| {
        w.path.to_string_lossy().contains(path_or_name)
            || w.branch.contains(path_or_name)
            || w.path
                .file_name()
                .is_some_and(|f| f.to_string_lossy().contains(path_or_name))
    })
    .ok_or_else(|| anyhow::anyhow!("找不到指定的 worktree: {}", path_or_name))?;
```

#### 批量清理功能
```rust
pub async fn clear_other_worktrees() -> anyhow::Result<usize> {
    let current_dir = std::env::current_dir()?;
    let worktrees = list_worktrees().await?;
    
    // 找到当前工作目录所属的worktree
    let current_worktree = worktrees
        .iter()
        .find(|w| w.path == current_dir || current_dir.starts_with(&w.path));
    
    let mut removed_count = 0;
    
    // 删除除当前外的所有其他worktrees
    for worktree in &worktrees {
        if worktree.path != current_path && !worktree.is_bare {
            // 使用--force强制删除
            match Command::new("git")
                .args(["worktree", "remove", "--force", &path_str])
                .status()
                .await
            {
                Ok(status) if status.success() => removed_count += 1,
                _ => { /* 记录失败但继续处理其他工作树 */ }
            }
        }
    }
    
    // 清理无效的worktree引用
    prune_worktrees().await?;
    
    Ok(removed_count)
}
```

## 4. 智能标签管理系统

### 4.1 语义化版本管理
支持完整的SemVer（语义化版本）规范：

```bash
# 自动递增补丁版本（1.0.0 → 1.0.1）
ai-commit --new-tag

# 指定大版本（自动从.0开始查找可用版本）
ai-commit --new-tag v2.0.0

# 指定完整版本（冲突时自动递增）
ai-commit --new-tag v1.2.3
```

### 4.2 版本解析和递增逻辑
```rust
async fn resolve_next_tag_name(base_version: Option<&str>) -> anyhow::Result<String> {
    let all_tags = get_all_tags().await?;
    
    let base_version = base_version.and_then(|v| {
        let trimmed = v.trim_start_matches('v');
        if trimmed.is_empty() { None } else { Some(trimmed) }
    });
    
    let mut parts: Vec<u32>;
    
    if let Some(base) = base_version {
        // 用户指定了基础版本
        parts = base.split('.').filter_map(|s| u32::from_str(s).ok()).collect();
        if parts.len() == 2 { parts.push(0); } // 补充patch版本
    } else {
        // 从最新标签递增
        let latest_tag_str = get_latest_tag_version().await
            .unwrap_or_else(|| "v0.0.0".to_string());
        let base = latest_tag_str.trim_start_matches('v');
        parts = base.split('.').filter_map(|s| u32::from_str(s).ok()).collect();
        parts[2] += 1; // 递增patch版本
    }
    
    // 循环查找可用版本号
    loop {
        let final_tag = format!("v{}.{}.{}", parts[0], parts[1], parts[2]);
        if !all_tags.contains(&final_tag) {
            return Ok(final_tag);
        }
        parts[2] += 1; // 冲突时自动递增
    }
}
```

### 4.3 标签缓存优化
```rust
// 使用异步Mutex缓存标签列表
static TAGS_CACHE: Lazy<tokio::sync::Mutex<Option<HashSet<String>>>> =
    Lazy::new(|| tokio::sync::Mutex::new(None));

async fn get_all_tags() -> anyhow::Result<HashSet<String>> {
    // 检查缓存
    {
        let cache = TAGS_CACHE.lock().await;
        if let Some(ref tags) = *cache {
            return Ok(tags.clone());
        }
    }
    
    // 获取标签列表并更新缓存
    let output = Command::new("git").args(["tag", "-l"]).output().await?;
    let tags: HashSet<String> = String::from_utf8(output.stdout)?
        .lines()
        .map(|s| s.trim().to_owned())
        .filter(|s| !s.is_empty())
        .collect();
    
    // 更新缓存
    *TAGS_CACHE.lock().await = Some(tags.clone());
    Ok(tags)
}
```

### 4.4 推送策略控制
```bash
# 安全推送：仅推送标签
ai-commit --new-tag --push

# 批量推送：同时推送常用分支和标签
ai-commit --new-tag --push --push-branches
```

**推送逻辑**：
```rust
pub async fn push_tag(tag: &str, allow_push_branches: bool) -> anyhow::Result<()> {
    let mut push_args = vec!["push", "origin"];
    
    if allow_push_branches {
        // 检查并添加存在的分支
        let existing_branches = get_existing_branches().await?;
        for branch in ["master", "develop", "main"] {
            if existing_branches.contains(branch) {
                push_args.push(branch);
            }
        }
    }
    
    push_args.push(tag);
    
    let status = Command::new("git").args(&push_args).status().await?;
    // 处理推送结果...
}
```

## 5. 性能优化策略

### 5.1 HTTP客户端优化
```rust
// 全局HTTP客户端复用
static HTTP_CLIENT: Lazy<Client> = Lazy::new(|| {
    Client::builder()
        .pool_max_idle_per_host(10)        // 最大10个空闲连接
        .pool_idle_timeout(Duration::from_secs(30))  // 30秒超时
        .build()
        .expect("Failed to create HTTP client")
});
```

### 5.2 正则表达式预编译
```rust
// 预编译验证正则表达式，提升性能
static INVALID_RESPONSE_PATTERNS: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?i)(\{\{git_diff\}\}|输出格式|git diff:|these are|here's a)")
        .unwrap()
});

static VALID_COMMIT_FORMAT: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"^(feat|fix|docs|style|refactor|test|chore)(\([^)]+\))?:\s+\S+.*$")
        .unwrap()
});
```

### 5.3 内存管理优化
```rust
// 预分配缓冲区，减少内存重新分配
let mut message = String::with_capacity(2048);  // 预分配字符串缓冲区
let mut buffer = Vec::with_capacity(8192);      // 预分配字节缓冲区

// 批量处理阈值
if buffer.len() > 4096 {
    process_chunk(&buffer).await?;
    buffer.clear();  // 及时释放内存
}
```

### 5.4 Git操作优化
```rust
// 并行执行多个Git命令
pub async fn git_status_and_diff() -> anyhow::Result<(String, String)> {
    let (status_result, diff_result) = tokio::join!(
        Command::new("git").args(["status", "--porcelain"]).output(),
        Command::new("git").args(["diff", "--cached"]).output()
    );
    // 处理结果...
}
```

## 6. 配置管理系统

### 6.1 多层级配置架构
```rust
pub struct Config {
    pub provider: String,
    pub model: String,
    pub deepseek_api_key: Option<String>,
    pub deepseek_url: String,
    pub ollama_url: String,
    pub siliconflow_api_key: Option<String>,
    pub siliconflow_url: String,
    pub debug: bool,
}

impl Config {
    pub fn new() -> Self {
        let mut config = Config::default();
        config.load_from_env();  // 加载环境变量
        config
    }
    
    pub fn update_from_args(&mut self, args: &Args) {
        // 命令行参数优先级最高
        if !args.provider.is_empty() {
            self.provider = args.provider.clone();
        }
        if !args.model.is_empty() {
            self.model = args.model.clone();
        }
    }
}
```

### 6.2 环境变量缓存机制
```rust
// 全局环境变量缓存
static ENV_VARS_CACHE: Lazy<std::sync::Mutex<Option<EnvVars>>> =
    Lazy::new(|| std::sync::Mutex::new(None));

impl EnvVars {
    fn load() -> Self {
        // 检查缓存
        {
            let cache = ENV_VARS_CACHE.lock().unwrap();
            if let Some(ref cached_vars) = *cache {
                return cached_vars.clone();
            }
        }
        
        // 批量读取环境变量
        let vars = Self {
            provider: env::var("AI_COMMIT_PROVIDER").ok(),
            model: env::var("AI_COMMIT_MODEL").ok(),
            deepseek_api_key: env::var("AI_COMMIT_DEEPSEEK_API_KEY").ok(),
            // ... 其他变量
        };
        
        // 更新缓存
        *ENV_VARS_CACHE.lock().unwrap() = Some(vars.clone());
        vars
    }
}
```

### 6.3 配置验证系统
```rust
pub fn validate(&self) -> anyhow::Result<()> {
    match self.provider.as_str() {
        "deepseek" => {
            if self.deepseek_api_key.is_none() {
                anyhow::bail!("Deepseek API key is required but not set. Please set AI_COMMIT_DEEPSEEK_API_KEY environment variable");
            }
        }
        "siliconflow" => {
            if self.siliconflow_api_key.is_none() {
                anyhow::bail!("SiliconFlow API key is required but not set. Please set AI_COMMIT_SILICONFLOW_API_KEY environment variable");
            }
        }
        "ollama" => {
            // Ollama使用本地服务，不需要API key
        }
        _ => {
            anyhow::bail!("Unsupported provider: {}", self.provider);
        }
    }
    Ok(())
}
```

## 7. 国际化支持

### 7.1 多语言支持
```rust
pub enum Language {
    ZhCn,  // 简体中文
    ZhTw,  // 繁体中文
    En,    // 英语
}

pub fn get_message(key: &str, lang: Language) -> &'static str {
    match (key, lang) {
        ("git_repo_not_found", Language::ZhCn) => "未找到Git仓库",
        ("git_repo_not_found", Language::ZhTw) => "未找到Git倉庫",
        ("git_repo_not_found", Language::En) => "Git repository not found",
        // ... 更多消息
    }
}
```

### 7.2 动态语言切换
```bash
# 通过环境变量设置语言
AI_COMMIT_LANGUAGE=en ai-commit --help

# 通过配置文件设置
echo "AI_COMMIT_LANGUAGE=zh-tw" >> ~/.ai-commit/.env
```

## 8. 错误处理与调试

### 8.1 统一错误处理
```rust
// 使用anyhow进行统一错误处理
pub async fn generate_commit_message(
    diff: &str,
    config: &Config,
    prompt: &str,
) -> anyhow::Result<String> {
    // 各种可能的错误都会被统一处理
    let response = make_request(client, url, api_key, &request).await
        .map_err(|e| anyhow::anyhow!("请求失败: {e}"))?;
    
    if !response.status().is_success() {
        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        anyhow::bail!("响应错误: 状态码 {status}, 响应体: {text}");
    }
    
    // ... 处理响应
}
```

### 8.2 调试模式支持
```bash
# 启用调试模式
AI_COMMIT_DEBUG=true ai-commit

# 调试输出示例
AI 生成 commit message 耗时: 1.23s
检测到大型变更 (6个文件, 15234字符)，正在生成摘要...
Created new tag: v1.0.1
Pushed tag v1.0.1 to remote
```

### 8.3 性能监控
```rust
if config.debug {
    let start_time = Instant::now();
    let message = ai::generate_commit_message(diff, config, &prompt).await?;
    let elapsed_time = start_time.elapsed();
    
    println!("AI 生成 commit message 耗时: {:.2?}", elapsed_time);
    
    if elapsed_time.as_secs() > 30 {
        println!("警告: AI 模型 '{}' 生成 commit message 耗时较长，建议更换更快的模型", config.model);
    }
}
```

---

以上详细介绍了AI-Commit的各项功能特性和技术实现。这些功能的设计都围绕着提升用户体验、保证代码质量和优化系统性能这三个核心目标。